<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Mahart Linked Notes - Fixed Version</title>
  <link rel="stylesheet" href="css/styles.css"/>
  <script src="https://cdn.jsdelivr.net/npm/localforage@1.10.0/dist/localforage.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.1.6/dist/purify.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script>
</head>
<body>
<div class="app">
  <div class="topbar">
    <div style="display: flex; gap: 8px;">
      <button id="newNote" class="btn">New Note (⌘/Ctrl+N)</button>
    </div>
    <button id="saveNote" class="btn">Save (⌘/Ctrl+S)</button>
    <div style="flex: 1; display: flex; gap: 8px; position: relative;">
      <div style="flex: 1; position: relative;">
        <input id="q" type="search" placeholder="Quick search (⌘/Ctrl+K): title, tags, body…" style="width: 100%;" autocomplete="off"/>
        <div id="searchSuggestions" class="search-suggestions" style="display: none;"></div>
      </div>
    </div>
    <button id="graphBtn" class="btn">Graph</button>
    <button id="exportBtn" class="btn">Export</button>
    <button id="importBtn" class="btn">Import</button>
    <button id="settingsBtn" class="btn">Settings</button>
  </div>

  <div class="left">
    <div class="section">
      <strong>Notes</strong> <span id="noteCount" class="badge">0</span>
      <div id="noteList"></div>
    </div>
    <div class="section">
      <strong>Tags</strong> <span id="tagCount" class="badge">0</span>
      <div id="tagList"></div>
    </div>
    <div class="section small">
      <strong>Backlinks</strong>
      <div id="backlinks"></div>
    </div>
  </div>

  <div class="main">
    <div class="card">
      <h3 style="display:flex;align-items:center;gap:8px;padding:12px;">
        Editor <span id="dirty" class="badge" style="display:none;">unsaved</span>
      </h3>
      <div class="editor">
        <textarea id="editor" placeholder="# Title

Write with **Markdown**.
Link notes with [[Note Title]] or [[ID:xxxx]].
Add tags with #tag anywhere.
"></textarea>
      </div>
      <div class="meta">
        <input id="title" placeholder="Title"/>
        <div class="tag-input-container">
            <div class="tags-display" id="tagsDisplay"></div>
            <input type="text" id="tagInput" class="tag-input-field" placeholder="Add tags..."/>
            <div class="tag-suggestions" id="tagSuggestions"></div>
        </div>
        <button id="saveNoteInline" class="btn" style="margin-left: 8px; padding: 8px 12px;" title="Save note (⌘/Ctrl+S)">Save</button>
      </div>
      <div class="editor-status" id="editorStatus" style="padding: 4px 12px; border-top: 1px solid #1a2133; font-size: 11px; color: var(--muted); background: #0f1422;">
        <span>Words: 0</span> | <span>Chars: 0</span> | <span>Lines: 1</span> | <span>Tags: 0</span> | <span>Links: 0</span>
      </div>
    </div>

    <div class="card">
      <h3 style="padding:12px;">Live Preview</h3>
      <div id="preview" class="preview"></div>
    </div>
  </div>

  <div class="right">
    <div class="panel">
      <div class="kpi">
        <div class="box"><div class="small">Notes</div><div id="kpiNotes" style="font-size:22px;"></div></div>
        <div class="box"><div class="small">Links/Note</div><div id="kpiLinks" style="font-size:22px;"></div></div>
        <div class="box"><div class="small">% ≥2 Links</div><div id="kpiHealth" style="font-size:22px;"></div></div>
      </div>
      <hr class="sep"/>
      <canvas id="chartActivity" height="120"></canvas>
      <hr class="sep"/>
      <div class="graph" id="miniGraph"></div>
    </div>

    <div class="panel small">
      <strong>Performance</strong>
      <div id="perfBox" class="code"></div>
    </div>

    <div class="panel small">
      <strong>Events</strong>
      <div id="eventLog" class="code" style="max-height:160px"></div>
    </div>
  </div>
</div>

<div id="toast" class="toast">Saved</div>

<dialog id="settings">
  <form method="dialog" class="card" style="padding:16px;min-width:420px">
    <h3>Settings</h3>
    <label class="small">Auto-link on save: <input id="autoLink" type="checkbox" checked></label>
    <label class="small">Enable analytics: <input id="enableAnalytics" type="checkbox" checked></label>
    <label class="small">Realtime multi-tab sync: <input id="enableBC" type="checkbox" checked></label>
    <hr class="sep"/>
    <button class="btn" value="cancel">Close</button>
  </form>
</dialog>

<input id="importFile" type="file" accept="application/json" hidden/>

<!-- Essential scripts only -->
<script src="js/util.js"></script>
<script src="js/store.js"></script>
<script src="js/search.js"></script>
<script src="js/analytics.js"></script>
<script src="js/graph.js"></script>
<script src="js/tags.js"></script>

<script>
// ESSENTIAL APP CORE - Simplified version that works
const UI = {
  state: { currentId: null, autoLink: true, analytics: true, bc: true },
  bc: null,
  
  async init() {
    console.log('Initializing UI...');
    this.bind();
    if (this.state.bc) this.bc = new BroadcastChannel('mahart-notes');
    if (this.bc) this.bc.onmessage = async (e) => { if (e.data?.type === 'sync') { await this.refresh(); }};
    await this.refresh();
    
    // Auto-open first note or create one
    const notes = await Store.allNotes();
    if (notes.length === 0) {
      await this.newNote();
    } else {
      await this.openNote(notes[0].id);
    }
    
    console.log('UI initialized successfully');
  },
  
  bind() {
    const editor = el('#editor');
    const title = el('#title');
    
    if (editor) {
      // Live preview update
      editor.addEventListener('input', () => {
        console.log('Editor input - updating preview');
        this.renderPreviewLive();
        this.updateEditorStats();
        const dirty = el('#dirty');
        if (dirty) dirty.style.display = 'inline-block';
      });
      
      editor.addEventListener('paste', () => {
        setTimeout(() => {
          this.renderPreviewLive();
          this.updateEditorStats();
        }, 10);
      });
    }
    
    if (title) {
      title.addEventListener('input', () => {
        const dirty = el('#dirty');
        if (dirty) dirty.style.display = 'inline-block';
      });
    }
    
    // Button bindings
    const newBtn = el('#newNote');
    if (newBtn) newBtn.onclick = () => this.newNote();
    
    const saveBtn = el('#saveNote');
    if (saveBtn) saveBtn.onclick = () => this.save();
    
    const saveInlineBtn = el('#saveNoteInline');
    if (saveInlineBtn) saveInlineBtn.onclick = () => this.save();
    
    const exportBtn = el('#exportBtn');
    if (exportBtn) exportBtn.onclick = () => this.export();
    
    const settingsBtn = el('#settingsBtn');
    if (settingsBtn) settingsBtn.onclick = () => el('#settings').showModal();
    
    // Search
    const searchBox = el('#q');
    if (searchBox) {
      searchBox.addEventListener('input', debounce(() => {
        this.performSearch(searchBox.value);
      }, 200));
    }
  },
  
  renderPreviewLive() {
    const editor = el('#editor');
    const preview = el('#preview');
    
    if (!editor || !preview) {
      console.error('Preview elements not found');
      return;
    }
    
    const content = editor.value;
    const rendered = renderMD(content);
    preview.innerHTML = rendered;
    
    console.log('Live preview updated');
  },
  
  updateEditorStats() {
    const editor = el('#editor');
    const status = el('#editorStatus');
    
    if (!editor || !status) return;
    
    const content = editor.value;
    const words = content.trim() ? content.trim().split(/\s+/).length : 0;
    const chars = content.length;
    const lines = content.split('\n').length;
    const tags = (content.match(/#[a-z0-9_\-]+/gi) || []).length;
    const links = (content.match(/\[\[([^\]]+)\]\]/g) || []).length;
    
    status.innerHTML = `
      <span>Words: ${words}</span> | 
      <span>Chars: ${chars}</span> | 
      <span>Lines: ${lines}</span> | 
      <span>Tags: ${tags}</span> | 
      <span>Links: ${links}</span>
    `;
  },
  
  async refresh() {
    const notes = await Store.allNotes();
    this.renderList(notes);
    this.renderTags(notes);
    this.renderBacklinks();
    this.renderKPI(notes);
  },
  
  renderList(notes) {
    const box = el('#noteList');
    if (!box) return;
    
    box.innerHTML = '';
    const sorted = [...notes].sort((a,b) => (b.updatedAt||'').localeCompare(a.updatedAt||''));
    
    for (const n of sorted) {
      const div = document.createElement('div');
      div.className = 'item';
      div.innerHTML = `<div style="padding:6px 4px;cursor:pointer">
        <div>${n.title || '(untitled)'}</div>
        <div class="small">${(n.updatedAt||n.createdAt).slice(0,16).replace('T',' ')}</div>
      </div>`;
      div.onclick = () => this.openNote(n.id);
      box.appendChild(div);
    }
    
    const noteCount = el('#noteCount');
    if (noteCount) noteCount.textContent = notes.length;
  },
  
  renderTags(notes) {
    const box = el('#tagList');
    if (!box) return;
    
    const tagCounts = {};
    for (const n of notes) {
      for (const tag of n.tags || []) {
        tagCounts[tag] = (tagCounts[tag] || 0) + 1;
      }
    }
    
    const items = Object.entries(tagCounts).sort((a,b) => b[1] - a[1]);
    box.innerHTML = '';
    
    for (const [tag, count] of items.slice(0, 20)) {
      const div = document.createElement('div');
      div.className = 'item';
      div.innerHTML = `<div style="padding:4px;cursor:pointer;display:flex;justify-content:space-between;">
        <span>${tag}</span><span class="badge">${count}</span>
      </div>`;
      div.onclick = () => this.filterByTag(tag);
      box.appendChild(div);
    }
    
    const tagCount = el('#tagCount');
    if (tagCount) tagCount.textContent = items.length;
  },
  
  renderBacklinks() {
    const id = this.state.currentId;
    const box = el('#backlinks');
    if (!box) return;
    box.innerHTML = '';
    if (!id) return;
    
    Store.allNotes().then(notes => {
      const list = Note.backlinks(id, notes);
      for (const n of list) {
        const div = document.createElement('div');
        div.innerHTML = `<a class="link">${n.title||n.id}</a>`;
        div.onclick = () => this.openNote(n.id);
        box.appendChild(div);
      }
    }).catch(console.error);
  },
  
  renderKPI(notes) {
    const total = notes.length;
    const linksPer = total ? (notes.reduce((a,n) => a + (n.links?.length || 0), 0) / total) : 0;
    const pct2 = total ? (100 * notes.filter(n => (n.links?.length || 0) >= 2).length / total) : 0;
    
    const kpiNotes = el('#kpiNotes');
    const kpiLinks = el('#kpiLinks');
    const kpiHealth = el('#kpiHealth');
    
    if (kpiNotes) kpiNotes.textContent = total;
    if (kpiLinks) kpiLinks.textContent = linksPer.toFixed(1);
    if (kpiHealth) kpiHealth.textContent = pct2.toFixed(0) + '%';
  },
  
  async openNote(id) {
    const n = await Store.get(id);
    if (!n) return;
    
    this.state.currentId = n.id;
    const title = el('#title');
    const editor = el('#editor');
    const dirty = el('#dirty');
    
    if (title) title.value = n.title || '';
    if (editor) editor.value = n.body || '';
    if (dirty) dirty.style.display = 'none';
    
    this.renderPreviewLive();
    this.updateEditorStats();
    this.renderBacklinks();
    
    console.log('Opened note:', n.title);
  },
  
  async newNote() {
    const n = Note.create({ title: 'New Note', body: '# New Note\n\nStart writing here...' });
    await Store.upsert(n);
    await this.openNote(n.id);
    await this.refresh();
    console.log('Created new note');
  },
  
  async save() {
    if (!this.state.currentId) {
      await this.newNote();
      return;
    }
    
    const n = await Store.get(this.state.currentId);
    const title = el('#title');
    const editor = el('#editor');
    
    if (title) n.title = title.value.trim() || n.title || '(untitled)';
    if (editor) n.body = editor.value;
    n.updatedAt = nowISO();
    
    // Extract tags from content
    const tags = [...new Set((editor.value.match(/#[a-z0-9_\-]+/gi) || []).map(t => t.toLowerCase()))];
    n.tags = tags;
    
    // Compute links
    const notes = await Store.allNotes();
    Note.computeLinks(n, notes);
    
    await Store.upsert(n);
    
    const dirty = el('#dirty');
    if (dirty) dirty.style.display = 'none';
    
    toast('Saved');
    await this.refresh();
    console.log('Saved note');
  },
  
  async export() {
    const notes = await Store.allNotes();
    const data = { notes, exportedAt: nowISO() };
    const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const a = Object.assign(document.createElement('a'), {href: url, download: `notes-${Date.now()}.json`});
    a.click();
    URL.revokeObjectURL(url);
    toast('Exported');
  },
  
  filterByTag(tag) {
    const searchBox = el('#q');
    if (searchBox) {
      searchBox.value = tag;
      this.performSearch(tag);
    }
  },
  
  async performSearch(query) {
    if (!query.trim()) {
      await this.refresh();
      return;
    }
    
    const notes = await Store.allNotes();
    const filtered = notes.filter(n => 
      (n.title || '').toLowerCase().includes(query.toLowerCase()) ||
      (n.body || '').toLowerCase().includes(query.toLowerCase()) ||
      (n.tags || []).some(tag => tag.toLowerCase().includes(query.toLowerCase()))
    );
    
    this.renderList(filtered);
  }
};

// Global functions
window.openWikiLink = (link) => {
  console.log('Wiki link clicked:', link);
  toast('Wiki link: ' + link);
};

// Initialize when DOM loads
document.addEventListener('DOMContentLoaded', () => {
  console.log('DOM loaded, initializing app...');
  UI.init().catch(console.error);
});
</script>

</body>
</html>